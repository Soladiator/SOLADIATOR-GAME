generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  walletAddress String     @id
  username      String?
  avatarURL     String?
  items         Item[]
  createdAt     DateTime   @default(now())
  gladiator     Gladiator?
}

//Gladiator is the model that will be used for real players
model Gladiator {
  id          Int       @id @default(autoincrement())
  character   Character @relation(fields: [characterId], references: [id])
  characterId Int       @unique
  owner       User      @relation(fields: [ownerWallet], references: [walletAddress])
  ownerWallet String    @unique

  gender Gender

  monsterGladiatorStats MonsterGladiatorStat[]

  maxEnergy         Int      @default(100)
  currentEnergy     Int      @default(100)
  lastEnergyRefresh DateTime @default(now())
  energyRefreshRate Int      @default(1) //1 energy per minute

  equippedItems EquippedItems?
}

//Character is the main model that will be used to play the game
//Monsters & Bosses will be created using the same model
model Character {
  id   Int    @id @default(autoincrement())
  name String

  //Is gladiator or monster
  gladiator Gladiator?
  Monster   Monster?

  characterStat     CharacterStat[]
  level             Int             @default(1)
  currentHealth     Int
  lastHealthRefresh DateTime        @default(now())
  healthRefreshRate Int             @default(1) //1 health per minute

  //Experience is used to get the level of the character
  experience          Int @default(0)
  availableStatPoints Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model CharacterStat {
  id          Int       @id @default(autoincrement())
  statType    StatType
  value       Int       @default(5)
  characterId Int
  character   Character @relation(fields: [characterId], references: [id])

  updatedAt DateTime @default(now()) @updatedAt

  //Below enforces that the combination of characterId and statType is unique
  @@unique([characterId, statType])
}

model Item {
  id          Int      @id @default(autoincrement())
  name        String
  imgURL      String?
  itemType    ItemType
  minLevel    Int      @default(1)
  //Attributes are stored as a JSON object in format of 
  // Array<{
  //  name: "damage" | "damageReduction" | StatType,
  //  value: string  //For bonuses: "<BonusType>:<value>", For damage: "min-max", For "damageReduction": "value"
  // }>
  attributes  Json
  owner       User     @relation(fields: [ownerWallet], references: [walletAddress])
  ownerWallet String

  createdAt DateTime @default(now())

  weaponEquippedBy   EquippedItems? @relation("Weapon")
  armorEquippedBy    EquippedItems? @relation("Armor")
  helmetEquippedBy   EquippedItems? @relation("Helmet")
  shieldEquippedBy   EquippedItems? @relation("Shield")
  bootsEquippedBy    EquippedItems? @relation("Boots")
  glovesEquippedBy   EquippedItems? @relation("Gloves")
  ring1EquippedBy    EquippedItems? @relation("Ring1")
  ring2EquippedBy    EquippedItems? @relation("Ring2")
  necklaceEquippedBy EquippedItems? @relation("Necklace")
}

model EquippedItems {
  id          Int       @id @default(autoincrement())
  gladiator   Gladiator @relation(fields: [gladiatorId], references: [id])
  gladiatorId Int       @unique

  weaponId   Int? @unique
  armorId    Int? @unique
  helmetId   Int? @unique
  shieldId   Int? @unique
  bootsId    Int? @unique
  glovesId   Int? @unique
  ring1Id    Int? @unique
  ring2Id    Int? @unique
  necklaceId Int? @unique

  weapon   Item? @relation("Weapon", fields: [weaponId], references: [id])
  armor    Item? @relation("Armor", fields: [armorId], references: [id])
  helmet   Item? @relation("Helmet", fields: [helmetId], references: [id])
  shield   Item? @relation("Shield", fields: [shieldId], references: [id])
  boots    Item? @relation("Boots", fields: [bootsId], references: [id])
  gloves   Item? @relation("Gloves", fields: [glovesId], references: [id])
  ring1    Item? @relation("Ring1", fields: [ring1Id], references: [id])
  ring2    Item? @relation("Ring2", fields: [ring2Id], references: [id])
  necklace Item? @relation("Necklace", fields: [necklaceId], references: [id])
}

model Monster {
  id          Int       @id @default(autoincrement())
  character   Character @relation(fields: [characterId], references: [id])
  characterId Int       @unique

  //Difficulty per zone
  difficulty Difficulty

  monsterGladiatorStats MonsterGladiatorStat[]
  battleZone            BattleZone             @relation(fields: [battleZoneName], references: [name])
  battleZoneName        String

  MonsterBonus MonsterBonus[]

  createdAt DateTime @default(now())
}

model MonsterGladiatorStat {
  id          Int       @id @default(autoincrement())
  characterId Int
  character   Monster   @relation(fields: [characterId], references: [id])
  gladiatorId Int
  gladiator   Gladiator @relation(fields: [gladiatorId], references: [id])

  gladiatorWins Int @default(0)
  gladiatorLoss Int @default(0)

  updatedAt DateTime @default(now()) @updatedAt

  @@unique([gladiatorId, characterId])
}

model MonsterBonus {
  id        Int               @id @default(autoincrement())
  bonusType MonsterBonusTypes
  value     Int
  monster   Monster?          @relation(fields: [monsterId], references: [id])
  monsterId Int?

  requiredWins Int
}

model BattleZone {
  name String @id

  //Monsters belonging to the zone
  monsters Monster[]

  minLevel Int @default(1)

  createdAt DateTime @default(now())
}

enum ItemType {
  Weapon
  Armor
  Boots
  Helmet
  Shield
  Gloves
  Ring
  Necklace
}

enum StatType {
  STR
  VIT
  DEX
  DEF
  LCK
}

enum Difficulty {
  Easy
  Medium
  Hard
  Boss
}

enum Gender {
  Male
  Female
}

enum MonsterBonusTypes {
  IncreasedExperience
  IncreasedGold
  IncreasedItemDrop
}
